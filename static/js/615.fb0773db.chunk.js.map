{"version":3,"file":"static/js/615.fb0773db.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts","../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts","../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts","../node_modules/pixi.js/src/scene/container/utils/buildInstructions.ts","../node_modules/pixi.js/src/scene/container/utils/clearList.ts","../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts","../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts","../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts","../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts","../node_modules/pixi.js/src/filters/Filter.ts","../node_modules/pixi.js/src/filters/mask/MaskFilter.ts","../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts","../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts","../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts","../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts","../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts","../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts","../node_modules/pixi.js/src/utils/sayHello.ts","../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts","../node_modules/pixi.js/src/utils/data/clean.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n","import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n","import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n};\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n","// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n}\n","import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n","import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @memberof rendering\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n","import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n","import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n","// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\nexport interface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @memberof rendering\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n","import type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Renderer, RenderPipes } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @deprecated since 8.3.0\n */\nexport function buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\nexport function buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\nexport function buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n{\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n\n    instructionSet.reset();\n\n    // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n    const renderer = (rendererOrPipes as Renderer).renderPipes\n        ? (rendererOrPipes as Renderer)\n        : (rendererOrPipes as RenderPipes).batch.renderer;\n    const renderPipes = renderer.renderPipes;\n\n    // TODO add some events / runners for build start\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n\n    if (root.sortableChildren)\n    {\n        root.sortChildren();\n    }\n\n    collectAllRenderablesAdvanced(root, instructionSet, renderer, true);\n\n    // TODO add some events / runners for build end\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n}\n\n/**\n * @param container\n * @param instructionSet\n * @param renderer\n * @deprecated since 8.3.0\n */\nexport function collectAllRenderables(container: Container, instructionSet: InstructionSet, renderer: RenderPipes): void;\nexport function collectAllRenderables(container: Container, instructionSet: InstructionSet, renderer: Renderer): void;\nexport function collectAllRenderables(\n    container: Container, instructionSet: InstructionSet, rendererOrPipes: Renderer | RenderPipes\n): void\n{\n    // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n    const renderer = (rendererOrPipes as Renderer).renderPipes\n        ? (rendererOrPipes as Renderer)\n        : (rendererOrPipes as RenderPipes).batch.renderer;\n\n    // if there is 0b01 or 0b10 the return value\n    if (container.globalDisplayStatus < 0b111 || !container.includeInBuild) return;\n\n    if (container.sortableChildren)\n    {\n        container.sortChildren();\n    }\n\n    if (container.isSimple)\n    {\n        collectAllRenderablesSimple(container, instructionSet, renderer);\n    }\n    else\n    {\n        collectAllRenderablesAdvanced(container, instructionSet, renderer, false);\n    }\n}\n\nfunction collectAllRenderablesSimple(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderer: Renderer,\n): void\n{\n    if (container.renderPipeId)\n    {\n        const renderable = container as Renderable;\n        const { renderPipes, renderableGC } = renderer;\n\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(renderable, container.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[renderable.renderPipeId].addRenderable(renderable, instructionSet);\n\n        renderableGC.addRenderable(renderable);\n\n        renderable.didViewUpdate = false;\n    }\n\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            collectAllRenderables(children[i], instructionSet, renderer);\n        }\n    }\n}\n\nfunction collectAllRenderablesAdvanced(\n    container: Container,\n    instructionSet: InstructionSet,\n    renderer: Renderer,\n    isRoot: boolean\n): void\n{\n    const { renderPipes, renderableGC } = renderer;\n\n    if (!isRoot && container.renderGroup)\n    {\n        renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n    }\n    else\n    {\n        for (let i = 0; i < container.effects.length; i++)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.push(effect, container, instructionSet);\n        }\n\n        const renderable = container as Renderable;\n        const renderPipeId = renderable.renderPipeId;\n\n        if (renderPipeId)\n        {\n            // TODO add blends in\n            renderPipes.blendMode.setBlendMode(renderable, renderable.groupBlendMode, instructionSet);\n\n            const pipe = renderPipes[renderPipeId as keyof RenderPipes]as RenderPipe<any>;\n\n            pipe.addRenderable(renderable, instructionSet);\n\n            renderableGC.addRenderable(renderable);\n\n            renderable.didViewUpdate = false;\n        }\n\n        const children = container.children;\n\n        if (children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                collectAllRenderables(children[i], instructionSet, renderer);\n            }\n        }\n\n        // loop backwards through effects\n        for (let i = container.effects.length - 1; i >= 0; i--)\n        {\n            const effect = container.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes]as InstructionPipe<any>;\n\n            pipe.pop(effect, container, instructionSet);\n        }\n    }\n}\n\n","/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n","import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { buildInstructions } from './utils/buildInstructions';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender();\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n}\n\n","import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { Sprite } from './Sprite';\n\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuSpriteHash: Record<number, BatchableSprite> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    public destroyRenderable(sprite: Sprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = BigPool.get(BatchableSprite);\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            BigPool.return(this._gpuSpriteHash[i] as PoolItem);\n        }\n\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @memberof rendering\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher();\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            collectAllRenderables(\n                maskContainer,\n                instructionSet,\n                renderer\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        this._colorStack = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        collectAllRenderables(\n            maskContainer,\n            instructionSet,\n            renderer,\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n\n/**\n * Options for the background system.\n * @property {ColorSource} [backgroundColor='black']\n * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n * @property {ColorSource} [background] - Alias for backgroundColor\n * @property {number} [backgroundAlpha=1] -\n * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n * @property {boolean} [clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n * @memberof rendering\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @memberof rendering.SharedRendererOptions\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /**\n     * Alias for backgroundColor\n     * @memberof rendering.SharedRendererOptions\n     */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @memberof rendering.SharedRendererOptions\n     * @default 1\n     */\n    backgroundAlpha: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @memberof rendering.SharedRendererOptions\n     * @default true\n     */\n    clearBeforeRender: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @memberof rendering\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        let filterEffect = this._filterHash[blendMode];\n\n        // this does need an execute?\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect,\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * @memberof rendering\n */\nexport interface ImageOptions\n{\n    /** The format of the image. */\n    format?: Formats;\n    /** The quality of the image. */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport interface BaseExtractOptions\n{\n    /** The target to extract. */\n    target: Container | Texture;\n    /** The region of the target to extract. */\n    frame?: Rectangle;\n    /** The resolution of the extracted content. */\n    resolution?: number;\n    /** The color used to clear the extracted content. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * @memberof rendering\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * @memberof rendering\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /** The filename to use when downloading the content. */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .circle(0, 0, 50);\n *     .fill(0xFF0000)\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof rendering\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /** Default options for creating an image. */\n    public static defaultImageOptions: ImageOptions = {\n        /** The format of the image. */\n        format: 'png' as Formats,\n        /** The quality of the image. */\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param options - The options for creating the image, or the target to extract\n     * @returns - HTML Image of the target\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     * `Extract.canvas` and then running toDataURL on that.\n     * @param options - The options for creating the image, or the target to extract\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Will return a texture of the target\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns - A texture of the target\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Will extract a HTMLImage of the target and download it\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * @param options - The options for logging the image, or the target to log\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link rendering.Texture}\n * @memberof rendering\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n","import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @memberof rendering\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @memberof rendering\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n","import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @memberof rendering\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @memberof rendering.SharedRendererOptions\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @memberof rendering\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n","/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @memberof utils\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @memberof utils\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\nimport { type RenderGroup } from '~/scene/container/RenderGroup';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @memberof rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n *\n * Example:\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @implements {System<RenderableGCSystemOptions>}\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @memberof rendering\n * @property {boolean} [textureGCActive=true] - If set to true, this will enable the garbage collector on the GPU.\n * @property {number} [textureGCAMaxIdle=60 * 60] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [textureGCCheckCountMax=600] - Frames between two garbage collections.\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystem.textureGCMaxIdle}\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @memberof rendering\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystem.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @memberof rendering\n * @property {number} [width=800] - The width of the screen.\n * @property {number} [height=600] - The height of the screen.\n * @property {ICanvas} [canvas] - The canvas to use as a view, optional.\n * @property {boolean} [autoDensity=false] - Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n * @property {number} [resolution] - The resolution / device pixel ratio of the renderer.\n * @property {boolean} [antialias=false] - Whether to enable anti-aliasing. This may affect performance.\n * @property {boolean} [depth] -\n * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n * @property {boolean} [multiView] - TODO: multiView\n * @property {number} [backgroundAlpha] - The alpha of the background.\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     * @memberof rendering.SharedRendererOptions\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    height?: number;\n    /**\n     * The canvas to use as a view, optional.\n     * @memberof rendering.SharedRendererOptions\n     */\n    canvas?: ICanvas;\n    /** @deprecated */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     * @memberof rendering.SharedRendererOptions\n     */\n    autoDensity?: boolean;\n    /**\n     * The resolution / device pixel ratio of the renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    resolution?: number;\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @memberof rendering.SharedRendererOptions\n     */\n    antialias?: boolean;\n    /**\n     * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    depth?: boolean;\n\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @default 1\n     */\n    backgroundAlpha?: number;\n}\n\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * @member {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = options.backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n","import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","_objectSpread","replace","localUniformBitGl","textureBit","fragment","textureBitGl","ensureAttributes","geometry","extractedData","i","attributes","attribute","attributeData","_attribute$format","_attribute$offset","_attribute$instance","format","offset","instance","warn","concat","buffers","tempStride","tempStart","j","buffer","uid","getAttributeInfoFromFormat","stride","_attribute$stride","_attribute$start","start","ensureStartAndStride","GpuStencilModesToPixi","STENCIL_MODES","NONE","DISABLED","stencilWriteMask","stencilReadMask","RENDERING_MASK_ADD","stencilFront","compare","passOp","stencilBack","RENDERING_MASK_REMOVE","MASK_ACTIVE","INVERSE_MASK_ACTIVE","BufferResource","EventEmitter","constructor","_ref","size","_resourceType","_touched","_resourceId","_bufferResource","destroyed","this","on","onBufferChange","emit","destroy","destroyBuffer","arguments","length","undefined","_RenderTarget","descriptor","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","defaultOptions","stencil","depth","push","TextureSource","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","onSourceResize","depthStencilTexture","Texture","ensureDepthStencilTexture","pixelWidth","pixelHeight","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","off","RenderTarget","RenderTargetSystem","renderer","rootViewPort","Rectangle","viewport","onRenderTargetChange","SystemRunner","projectionMatrix","Matrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","Object","create","_renderTargetStack","_renderer","renderableGC","addManagedHash","finishRenderPass","adaptor","renderTarget","renderStart","_this$adaptor$prerend","_this$adaptor","target","clear","clearColor","frame","copyFrom","rootRenderTarget","renderingToScreen","resource","globalThis","HTMLCanvasElement","document","body","contains","isRenderingToScreen","prerender","call","postrender","_this$adaptor$postren","_this$adaptor2","bind","renderSurface","getRenderTarget","didChange","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","x","y","pm","flipY","sign","identity","a","d","tx","ty","calculateProjection","startRenderPass","CLEAR","ALL","contextChange","pop","currentRenderTargetData","_this$_renderSurfaceT","isTexture","get","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","Math","min","ensureDepthStencil","key","CanvasSource","test","getCanvasTexture","once","delete","destroyGpuRenderTarget","set","initGpuRenderTarget","UboSystem","_syncFunctionHash","_adaptor","_systemCheck","unsafeEvalSupported","Error","ensureUniformGroup","uniformGroup","uniformData","getUniformGroupData","Buffer","data","layout","usage","BufferUsage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","uboElements","generateUboSync","syncUniformGroup","uniformGroupData","dataInt32","uniforms","updateUniformGroup","isStatic","_dirtyId","synced","update","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","uniformParsers","ubo","template","type","fragmentSrc","join","Function","loopMatrix","col","row","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","value","uniform","red","blendModeIds","normal","add","multiply","screen","overlay","erase","max","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","State","CustomRenderPipe","updateRenderable","destroyRenderable","validateRenderable","addRenderable","container","instructionSet","renderPipes","batch","break","execute","isRenderable","render","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","executeInstructions","renderGroup","instructions","instructionSize","instruction","renderPipeId","tempMatrix","RenderGroupPipe","addRenderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","BigPool","return","_renderGroup$_batchab","batchableRenderGroup","BatchableSprite","renderable","root","transform","relativeGroupTransform","bounds","_textureBounds","addToBatch","textureNeedsUpdate","worldTransformMatrix","translate","globalUniforms","worldColor","_batcher","updateElement","inverseParentTextureTransform","worldColorAlpha","collectAllRenderables","rendererOrPipes","globalDisplayStatus","includeInBuild","sortableChildren","sortChildren","isSimple","setBlendMode","groupBlendMode","didViewUpdate","children","collectAllRenderablesSimple","collectAllRenderablesAdvanced","effects","effect","pipe","clearList","list","index","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","worldTransform","appendFrom","multiplyColors","groupColor","groupAlpha","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","renderGroupChildren","updateFlags","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","structureDidChange","groupColorAlpha","localBlendMode","localDisplayStatus","RenderGroupSystem","originalLocalTransform","_updateCachedRenderGroups","_updateRenderGroups","uniformBatch","renderEnd","closestCacheAsTexture","updateCacheTexture","_parentCacheAsTextureRenderGroup","invalidateMatrices","_renderGroup$textureO","getLocalBounds","ceil","lastTexture","TexturePool","returnTexture","textureOptions","view","getOptimalTexture","Bounds","runOnRender","childrenRenderablesToUpdate","rebuildRequired","validateRenderables","reset","buildStart","colorMask","buildEnd","buildInstructions","_updateRenderables","upload","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","_gpuSpriteHash","_destroyRenderableBound","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","checkAndUpdateTexture","_texture","batchableSprite","visualBounds","_initGPUSprite","groupTransform","roundPixels","_roundPixels","_BatcherPipe","_this$_adaptor$init","_this$_adaptor","_batchersByInstructionSet","_activeBatches","init","getBatcher","_availableBatchers","batchers","default","DefaultBatcher","_activeBatch","begin","batchableObject","batcherName","batches","indexBuffer","setDataWithSize","indexSize","attributeBuffer","float32View","attributeSize","batcher","dirty","action","shader","BatcherPipe","extensions","handleByMap","Batcher","_Filter","Shader","options","super","enabled","_state","padding","blendRequired","clipToViewport","addResource","apply","filterManager","input","output","clearMode","applyFilter","from","gpu","gl","rest","_objectWithoutProperties","_excluded","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","MaskFilter","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","entryPoint","resources","uMaskTexture","_textureMatrix","calculateSpriteMatrix","prepend","mapCoord","tempBounds","AlphaMaskEffect","FilterEffect","filters","Sprite","EMPTY","AlphaMaskPipe","_activeMaskStage","mask","maskedContainer","_maskOptions","canBundle","renderMaskToTexture","maskContainer","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","colorTextureSource","filterTexture","minX","minY","maskData","RendererType","WEBGL","filter","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a$renderTargetUid","_a","has","instructionsStart","instructionsLength","renderTargetUid","_a$renderTargetUid2","maskStackIndex","setStencilMode","STENCIL","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","setValue","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","ref","BlendModePipe","_isAdvanced","_filterHash","_activeBlendMode","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","image","Image","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","_options$filename","link","createElement","filename","href","appendChild","click","removeChild","log","_options$width","console","style","ExtractSystem","RenderTexture","tempRect","noColor","GenerateTextureSystem","_options$frame","textureSourceOptions","Array","isArray","shared","region","copyTo","rectangle","updateMipmaps","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","color32BitToUniform","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","SchedulerSystem","_tasks","_offset","Ticker","system","_update","repeat","func","duration","id","performance","now","last","cancel","splice","task","elapsed","remove","saidHello","HelloSystem","hello","context","webGLVersion","DOMAdapter","getNavigator","userAgent","toLowerCase","indexOf","args","VERSION","sayHello","cleanHash","hash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","maxUnusedTime","renderableGCMaxUnusedTime","_frequency","renderableGCFrequency","renderableGCActive","_handler","scheduler","run","_hashHandler","_arrayHandler","array","addManagedArray","_now","gcTick","_updateInstructionGCTick","_lastUsed","_removeRenderable","managedRenderables","_renderable$renderGro","_renderGroup$instruct","_renderGroup$instruct2","_renderGroup$gcTick","currentTick","rp","RenderableGCSystem","_TextureGCSystem","count","checkCount","_options$textureGCAMa","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","textureGCMaxIdle","active","textureGCActive","managedTextures","autoGarbageCollect","unload","TextureGCSystem","_ViewSystem","autoDensity","deprecation","v8_0_0","createCanvas","transparent","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","SharedSystems","RendererInitHook","SharedRenderPipes","canvasCache","onDestroy","abgr","out","topology","packAsQuad","_attributeStart","_batch"],"sourceRoot":""}